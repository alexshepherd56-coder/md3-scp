<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Admin Dashboard - SCP Cases</title>

  <!-- Favicon -->
  <link rel="icon" type="image/svg+xml" href="assets/admin-favicon.svg">
  <link rel="alternate icon" type="image/png" href="assets/admin-favicon.png">

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;600;700&display=swap" rel="stylesheet">
  <style>
    * {
      box-sizing: border-box;
    }

    body {
      font-family: 'JetBrains Mono', 'Consolas', 'Monaco', monospace;
      margin: 0;
      padding: 20px;
      background: linear-gradient(135deg, #0a0e0a 0%, #1a1f1a 100%);
      color: #e0e0e0;
      font-size: 14px;
      line-height: 1.6;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
      cursor: default;
    }

    .dashboard-container {
      max-width: 1400px;
      margin: 0 auto;
      padding: 20px;
    }

    .dashboard-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 30px;
      padding: 30px;
      background: rgba(20, 30, 20, 0.6);
      border-left: 4px solid #00ff88;
      backdrop-filter: blur(10px);
      border-radius: 8px;
    }

    .dashboard-header h1 {
      margin: 0;
      color: #00ff88;
      font-size: 1.8em;
      font-weight: 600;
      letter-spacing: -0.5px;
      position: relative;
      display: inline-block;
    }

    .admin-badge {
      background: rgba(0, 255, 136, 0.1);
      padding: 8px 16px;
      border: 1px solid #00ff88;
      color: #00ff88;
      font-weight: 500;
      letter-spacing: 1px;
      border-radius: 4px;
      font-size: 0.85em;
    }

    .stats-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
      gap: 20px;
      margin-bottom: 30px;
    }

    .stat-card {
      background: rgba(20, 30, 20, 0.4);
      padding: 24px;
      border-left: 3px solid #00ff88;
      border-radius: 8px;
      backdrop-filter: blur(10px);
      transition: all 0.3s ease;
    }

    .stat-card:hover {
      background: rgba(20, 30, 20, 0.6);
      transform: translateY(-2px);
    }

    .stat-card h3 {
      margin: 0 0 12px 0;
      color: #888;
      font-size: 0.75em;
      text-transform: uppercase;
      letter-spacing: 1.5px;
      font-weight: 500;
    }

    .stat-value {
      font-size: 2.5em;
      font-weight: 700;
      color: #00ff88;
      margin: 0 0 8px 0;
    }

    .stat-subtext {
      font-size: 0.8em;
      color: #666;
      margin-top: 5px;
      font-weight: 400;
    }

    .users-table-container {
      background: rgba(20, 30, 20, 0.4);
      border-left: 3px solid #00ff88;
      border-radius: 8px;
      backdrop-filter: blur(10px);
      padding: 24px;
      overflow-x: auto;
    }

    .table-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
      padding-bottom: 16px;
      border-bottom: 1px solid rgba(0, 255, 136, 0.2);
    }

    .table-header h2 {
      margin: 0;
      color: #00ff88;
      font-size: 1.3em;
      font-weight: 600;
      letter-spacing: -0.5px;
    }

    .refresh-btn {
      background: rgba(0, 255, 136, 0.1);
      color: #00ff88;
      border: 1px solid #00ff88;
      padding: 10px 20px;
      cursor: pointer;
      font-size: 0.85em;
      font-family: 'JetBrains Mono', monospace;
      font-weight: 500;
      border-radius: 4px;
      transition: all 0.2s ease;
    }

    .refresh-btn:hover {
      background: rgba(0, 255, 136, 0.2);
      transform: translateY(-1px);
    }

    .users-table {
      width: 100%;
      border-collapse: collapse;
    }

    .users-table th,
    .users-table td {
      padding: 14px 16px;
      text-align: left;
      border-bottom: 1px solid rgba(255, 255, 255, 0.05);
    }

    .users-table th {
      background: rgba(0, 255, 136, 0.05);
      color: #888;
      font-weight: 600;
      text-transform: uppercase;
      font-size: 0.7em;
      letter-spacing: 1.2px;
    }

    .users-table tbody tr {
      transition: background 0.2s ease;
    }

    .users-table tbody tr:hover {
      background: rgba(0, 255, 136, 0.05);
    }

    .users-table td {
      color: #ccc;
      font-size: 0.9em;
    }

    .loading {
      text-align: center;
      padding: 40px;
      color: #888;
      font-size: 1em;
    }

    .error {
      background: rgba(255, 50, 50, 0.1);
      color: #ff5555;
      border-left: 3px solid #ff5555;
      padding: 16px;
      margin-bottom: 20px;
      border-radius: 4px;
    }

    .time-badge {
      background: rgba(0, 255, 136, 0.1);
      color: #00ff88;
      border: 1px solid rgba(0, 255, 136, 0.3);
      padding: 4px 10px;
      font-size: 0.85em;
      border-radius: 3px;
      font-weight: 500;
    }

    .online-indicator {
      display: inline-block;
      width: 8px;
      height: 8px;
      background: #00ff88;
      margin-right: 8px;
      border-radius: 50%;
      animation: pulse 2s ease-in-out infinite;
    }

    .offline-indicator {
      display: inline-block;
      width: 8px;
      height: 8px;
      background: #444;
      margin-right: 8px;
      border-radius: 50%;
    }

    @keyframes pulse {
      0%, 100% {
        opacity: 1;
        box-shadow: 0 0 0 0 rgba(0, 255, 136, 0.4);
      }
      50% {
        opacity: 0.8;
        box-shadow: 0 0 0 4px rgba(0, 255, 136, 0);
      }
    }

    .session-details {
      font-size: 0.8em;
      color: #666;
      margin-top: 4px;
    }

    .filters {
      display: flex;
      gap: 12px;
      margin-bottom: 20px;
    }

    .filter-input {
      padding: 10px 14px;
      border: 1px solid rgba(0, 255, 136, 0.3);
      background: rgba(0, 0, 0, 0.3);
      color: #ccc;
      font-size: 0.9em;
      font-family: 'JetBrains Mono', monospace;
      border-radius: 4px;
      transition: all 0.2s ease;
    }

    .filter-input:focus {
      outline: none;
      border-color: #00ff88;
      background: rgba(0, 0, 0, 0.5);
    }

    .export-btn {
      background: rgba(0, 255, 136, 0.1);
      color: #00ff88;
      border: 1px solid #00ff88;
      padding: 10px 20px;
      cursor: pointer;
      font-size: 0.85em;
      font-family: 'JetBrains Mono', monospace;
      font-weight: 500;
      margin-left: 10px;
      border-radius: 4px;
      transition: all 0.2s ease;
    }

    .export-btn:hover {
      background: rgba(0, 255, 136, 0.2);
      transform: translateY(-1px);
    }

    .auth-required {
      text-align: center;
      padding: 60px 20px;
      border-left: 3px solid #ff5555;
      background: rgba(255, 50, 50, 0.05);
      border-radius: 8px;
    }

    .auth-required h2 {
      color: #ff5555;
      margin-bottom: 20px;
      font-size: 1.5em;
      font-weight: 600;
    }

    .sign-in-btn {
      background: rgba(0, 255, 136, 0.1);
      color: #00ff88;
      border: 1px solid #00ff88;
      padding: 12px 30px;
      cursor: pointer;
      font-size: 0.9em;
      font-family: 'JetBrains Mono', monospace;
      font-weight: 500;
      margin-top: 20px;
      border-radius: 4px;
      transition: all 0.2s ease;
    }

    .sign-in-btn:hover {
      background: rgba(0, 255, 136, 0.2);
      transform: translateY(-1px);
    }


    /* Matrix Rain Background */
    #matrixCanvas {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: -1;
      opacity: 0.15;
      pointer-events: none;
    }

    /* CRT Flicker Animation */
    @keyframes crtFlicker {
      0% { opacity: 1; }
      50% { opacity: 0.95; }
      100% { opacity: 1; }
    }

    .crt-flicker {
      animation: crtFlicker 0.15s ease-in-out;
    }

    /* Neon Pulse Animation */
    @keyframes neonPulse {
      0%, 100% {
        text-shadow:
          0 0 5px rgba(0, 255, 136, 0.3),
          0 0 10px rgba(0, 255, 136, 0.2);
      }
      50% {
        text-shadow:
          0 0 8px rgba(0, 255, 136, 0.5),
          0 0 15px rgba(0, 255, 136, 0.3);
      }
    }

    /* Glitch Animation */
    @keyframes glitch {
      0% {
        transform: translate(0);
        text-shadow:
          0 0 10px rgba(0, 255, 136, 0.8),
          0 0 20px rgba(0, 255, 136, 0.6);
      }
      20% {
        transform: translate(-2px, 2px);
        text-shadow:
          2px 0 rgba(255, 0, 0, 0.7),
          -2px 0 rgba(0, 255, 255, 0.7);
      }
      40% {
        transform: translate(2px, -2px);
        text-shadow:
          -2px 0 rgba(255, 0, 0, 0.7),
          2px 0 rgba(0, 255, 255, 0.7);
      }
      60% {
        transform: translate(-1px, 1px);
        text-shadow:
          1px 0 rgba(255, 0, 0, 0.7),
          -1px 0 rgba(0, 255, 255, 0.7);
      }
      80% {
        transform: translate(1px, -1px);
        text-shadow:
          -1px 0 rgba(255, 0, 0, 0.7),
          1px 0 rgba(0, 255, 255, 0.7);
      }
      100% {
        transform: translate(0);
        text-shadow:
          0 0 10px rgba(0, 255, 136, 0.8),
          0 0 20px rgba(0, 255, 136, 0.6);
      }
    }

    .glitch-active {
      animation: glitch 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
    }

    /* Blinking Cursor */
    .cursor {
      display: inline-block;
      width: 2px;
      height: 1.2em;
      background-color: #00ff88;
      margin-left: 4px;
      animation: cursorBlink 1s step-end infinite;
      vertical-align: text-bottom;
    }

    @keyframes cursorBlink {
      0%, 50% { opacity: 1; }
      51%, 100% { opacity: 0; }
    }

    /* Roulette Spin Animation */
    @keyframes rouletteSpin {
      0% {
        transform: rotate(0deg);
        animation-timing-function: cubic-bezier(0.17, 0.67, 0.12, 0.99);
      }
      100% {
        transform: rotate(1440deg);
      }
    }

    .admin-favicon {
      transition: transform 0.3s ease;
      cursor: pointer;
    }

    .admin-favicon.spinning {
      animation: rouletteSpin 5s cubic-bezier(0.17, 0.67, 0.83, 0.67) forwards;
      pointer-events: none;
    }

    /* Normal pointer cursor for clickable elements */
    button, .refresh-btn, .export-btn, .sign-in-btn, a, input, select {
      cursor: pointer;
    }

    /* Admin Tools Button Hover Effects */
    button:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
    }

    button:active {
      transform: translateY(0);
    }
  </style>

  <!-- Firebase SDK -->
  <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-firestore-compat.js"></script>

  <!-- Firebase Configuration -->
  <script src="js/firebase-config.js"></script>

  <!-- Chart.js for visualizations -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
</head>
<body>
  <!-- Matrix Rain Background -->
  <canvas id="matrixCanvas"></canvas>

  <div class="dashboard-container">
    <!-- Auth Required Screen -->
    <div id="authRequired" class="auth-required" style="display: none;">
      <h2>Admin Access Required</h2>
      <p>Please sign in to view the admin dashboard.</p>
      <button class="sign-in-btn" onclick="window.location.href='index.html'">Go to Sign In</button>
    </div>

    <!-- Dashboard Content -->
    <div id="dashboardContent" style="display: none;">
      <div class="dashboard-header">
        <h1 id="dashboardTitle"></h1>
        <div style="display: flex; gap: 12px; align-items: center;">
          <button class="refresh-btn" onclick="checkSessionHealth()" title="Check which users don't have session data">üîç Session Health</button>
          <button class="refresh-btn" onclick="createRetroactiveSessions()" title="Create sessions for users who don't have any" style="background: rgba(168, 85, 247, 0.1); border-color: #a855f7; color: #a855f7;">üîß Create Missing Sessions</button>
          <img src="assets/admin-favicon.svg" alt="Admin" class="admin-favicon" id="adminFavicon" style="width: 40px; height: 40px;">
        </div>
      </div>

      <div id="errorMessage" class="error" style="display: none;"></div>

      <!-- Statistics Overview -->
      <div class="stats-grid">
        <div class="stat-card">
          <h3>Total Users</h3>
          <p class="stat-value" id="totalUsers" style="color: #a855f7;">-</p>
          <p class="stat-subtext">Registered accounts</p>
        </div>

        <div class="stat-card">
          <h3>Active Now</h3>
          <p class="stat-value" id="activeUsers">-</p>
          <p class="stat-subtext">Currently online</p>
        </div>

        <div class="stat-card">
          <h3>Total Sessions</h3>
          <p class="stat-value" id="totalSessions">-</p>
          <p class="stat-subtext">All time</p>
        </div>

        <div class="stat-card">
          <h3>Avg Session Time</h3>
          <p class="stat-value" id="avgSessionTime">-</p>
          <p class="stat-subtext">Minutes per session</p>
        </div>
      </div>

      <!-- Daily Active Users Chart -->
      <div class="dau-chart-section" style="margin-bottom: 30px;">
        <div class="users-table-container" style="padding: 24px;">
          <!-- Legend as Title -->
          <div class="table-header" style="margin-bottom: 20px; border-bottom: none; padding-bottom: 0;">
            <div id="dauChartLegend" style="display: flex; gap: 30px; align-items: center;">
              <div style="display: flex; align-items: center; gap: 8px;">
                <span style="display: inline-block; width: 12px; height: 12px; background: #a855f7; border-radius: 50%;"></span>
                <span style="color: #a855f7; font-size: 1.1em; font-weight: 600;">Total Users</span>
              </div>
              <div style="display: flex; align-items: center; gap: 8px;">
                <span style="display: inline-block; width: 12px; height: 12px; background: #00ff88; border-radius: 50%;"></span>
                <span style="color: #00ff88; font-size: 1.1em; font-weight: 600;">Daily Active Users</span>
              </div>
              <span style="color: #666; font-size: 0.85em; font-weight: 400; margin-left: auto;">(Since Nov 6, 2025 ‚Ä¢ AEST Timezone)</span>
            </div>
          </div>

          <div id="dauChartLoading" class="loading">Loading DAU data...</div>

          <div id="dauChartContent" style="display: none;">
            <div style="display: grid; grid-template-columns: 1fr 350px; gap: 20px;">
              <!-- Chart Area -->
              <div style="background: rgba(20, 30, 20, 0.4); border-left: 3px solid #00ff88; border-radius: 8px; padding: 24px; backdrop-filter: blur(10px); overflow-x: auto;">
                <div id="dauChartContainer" style="min-width: 100%; position: relative;">
                  <canvas id="dauChart" style="height: 400px;"></canvas>
                </div>
              </div>

              <!-- User List Panel -->
              <div style="background: rgba(20, 30, 20, 0.4); border-left: 3px solid #00ff88; border-radius: 8px; padding: 24px; backdrop-filter: blur(10px); height: 448px; overflow-y: auto;">
                <div id="dauUserList" style="color: #888; font-size: 0.9em; line-height: 1.8;">
                  <p style="margin: 0; padding: 20px 0; text-align: center;">Hover over the chart to see active users for that day</p>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>

      <!-- Past Exams Analytics -->
      <div class="users-table-container" style="margin-bottom: 30px;">
        <div class="table-header">
          <h2>Past Exams Analytics</h2>
          <button class="refresh-btn" onclick="loadExamAnalytics()">Refresh</button>
        </div>

        <div id="examLoading" class="loading">Loading exam analytics...</div>

        <div id="examContent" style="display: none;">
          <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 20px; margin-bottom: 20px;">
            <!-- Exam Stats Cards -->
            <div class="stat-card">
              <h3>Total Exam Views</h3>
              <p class="stat-value" id="totalExamViews" style="color: #a855f7;">-</p>
              <p class="stat-subtext">All exam resources</p>
            </div>

            <div class="stat-card">
              <h3>Unique Viewers</h3>
              <p class="stat-value" id="uniqueExamViewers">-</p>
              <p class="stat-subtext">Users who viewed exams</p>
            </div>

            <div class="stat-card">
              <h3>Most Popular</h3>
              <p class="stat-value" id="mostPopularExam" style="font-size: 1.2em;">-</p>
              <p class="stat-subtext">Top exam resource</p>
            </div>
          </div>

          <!-- Exam Resources Table -->
          <div style="background: rgba(20, 30, 20, 0.4); border-left: 3px solid #00ff88; border-radius: 8px; padding: 20px; backdrop-filter: blur(10px); overflow-x: auto;">
            <h3 style="color: #00ff88; margin: 0 0 16px 0; font-size: 1.1em;">Exam Resource Details</h3>
            <table class="users-table" style="display: table;">
              <thead>
                <tr>
                  <th>Resource</th>
                  <th>Type</th>
                  <th>Total Views</th>
                  <th>Unique Viewers</th>
                  <th>Last Viewed</th>
                </tr>
              </thead>
              <tbody id="examTableBody">
              </tbody>
            </table>
          </div>
        </div>
      </div>

      <!-- Users Table -->
      <div class="users-table-container">
        <div class="table-header">
          <h2>User Details</h2>
          <div>
            <button class="export-btn" onclick="exportToCSV()">Export CSV</button>
            <button class="refresh-btn" onclick="clearAllCaches(); loadDashboardData(true)">Refresh</button>
          </div>
        </div>

        <div class="filters">
          <input type="text" id="searchFilter" class="filter-input" placeholder="Search by email or name..." oninput="filterUsers()">
          <select id="statusFilter" class="filter-input" onchange="filterUsers()">
            <option value="all">All Users</option>
            <option value="active">Active Now</option>
            <option value="recent">Active Today</option>
          </select>
        </div>

        <div id="loadingMessage" class="loading">Loading user data...</div>

        <table class="users-table" id="usersTable" style="display: none;">
          <thead>
            <tr>
              <th>Status</th>
              <th>Email</th>
              <th>Name</th>
              <th>Last Sign In</th>
              <th>Last Active</th>
              <th>Total Time</th>
              <th>Sessions</th>
              <th>Joined</th>
            </tr>
          </thead>
          <tbody id="usersTableBody">
          </tbody>
        </table>
      </div>
    </div>
  </div>

  <script>
    let allUsers = [];
    let adminDb, adminAuth;

    // Admin emails to exclude from analytics
    const ADMIN_EMAILS = ['alex.shepherd56@gmail.com'];

    // Timezone configuration
    const TIMEZONE_OFFSET_HOURS = 11; // AEST (UTC+11) - Melbourne, Australia
    const TIMEZONE_NAME = 'AEST';

    // Cache configuration
    const CACHE_DURATION = 5 * 60 * 1000; // 5 minutes in milliseconds
    const CACHE_KEY_DASHBOARD = 'admin_dashboard_cache';
    const CACHE_KEY_DAU = 'admin_dau_cache';
    const CACHE_KEY_EXAM = 'admin_exam_cache';

    // Cache helper functions
    function getCachedData(key) {
      try {
        const cached = localStorage.getItem(key);
        if (!cached) return null;

        const { data, timestamp } = JSON.parse(cached);
        const age = Date.now() - timestamp;

        if (age < CACHE_DURATION) {
          console.log(`[CACHE] Using cached data for ${key} (age: ${Math.round(age/1000)}s)`);
          return data;
        } else {
          console.log(`[CACHE] Cache expired for ${key} (age: ${Math.round(age/1000)}s)`);
          localStorage.removeItem(key);
          return null;
        }
      } catch (error) {
        console.error('[CACHE] Error reading cache:', error);
        return null;
      }
    }

    function setCachedData(key, data) {
      try {
        const cacheObject = {
          data: data,
          timestamp: Date.now()
        };
        localStorage.setItem(key, JSON.stringify(cacheObject));
        console.log(`[CACHE] Cached data for ${key}`);
      } catch (error) {
        console.error('[CACHE] Error writing cache:', error);
        // If localStorage is full, clear old caches
        if (error.name === 'QuotaExceededError') {
          console.log('[CACHE] Quota exceeded, clearing caches');
          localStorage.removeItem(CACHE_KEY_DASHBOARD);
          localStorage.removeItem(CACHE_KEY_DAU);
          localStorage.removeItem(CACHE_KEY_EXAM);
        }
      }
    }

    function clearAllCaches() {
      localStorage.removeItem(CACHE_KEY_DASHBOARD);
      localStorage.removeItem(CACHE_KEY_DAU);
      localStorage.removeItem(CACHE_KEY_EXAM);
      console.log('[CACHE] All caches cleared');
    }

    // Sound Effects using Web Audio API
    const AudioContext = window.AudioContext || window.webkitAudioContext;
    let audioCtx = null;
    let audioInitialized = false;

    // Initialize audio context on first user interaction
    function initAudio() {
      if (!audioInitialized) {
        audioCtx = new AudioContext();
        audioInitialized = true;

        // Resume context if suspended
        if (audioCtx.state === 'suspended') {
          audioCtx.resume();
        }
      }
    }

    // Typewriter sound effect
    function playTypeSound() {
      if (!audioCtx) {
        try {
          initAudio();
        } catch (e) {
          return;
        }
      }

      if (!audioCtx) return;

      try {
        // Create typewriter key click
        const bufferSize = audioCtx.sampleRate * 0.015; // 15ms
        const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
        const data = buffer.getChannelData(0);

        // Generate noise for typewriter click
        for (let i = 0; i < bufferSize; i++) {
          data[i] = (Math.random() * 2 - 1) * Math.exp(-i / (bufferSize * 0.3));
        }

        const noise = audioCtx.createBufferSource();
        noise.buffer = buffer;

        const gainNode = audioCtx.createGain();
        const filter = audioCtx.createBiquadFilter();

        filter.type = 'bandpass';
        filter.frequency.value = 1500;
        filter.Q.value = 3;

        noise.connect(filter);
        filter.connect(gainNode);
        gainNode.connect(audioCtx.destination);

        gainNode.gain.setValueAtTime(0.04, audioCtx.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.015);

        noise.start(audioCtx.currentTime);
        noise.stop(audioCtx.currentTime + 0.015);
      } catch (e) {
        console.log('Audio not available');
      }
    }

    // Typewriter effect for dashboard title
    function typewriterEffect(element, text, speed = 80) {
      let index = 0;
      element.textContent = '';

      function typeNextChar() {
        if (index < text.length) {
          element.textContent += text.charAt(index);
          playTypeSound();
          index++;
          setTimeout(typeNextChar, speed);
        } else {
          // Start random glitch effect (without cursor)
          startRandomGlitch(element);
        }
      }

      typeNextChar();
    }

    // Random glitch effect that triggers occasionally
    function startRandomGlitch(element) {
      setInterval(() => {
        // 10% chance every 5 seconds
        if (Math.random() < 0.1) {
          element.classList.add('glitch-active');
          setTimeout(() => {
            element.classList.remove('glitch-active');
          }, 300);
        }
      }, 5000);
    }

    // Animated counter for statistics
    function animateCounter(element, target, duration = 1000, suffix = '') {
      const start = 0;
      const increment = target / (duration / 16); // 60fps
      let current = 0;

      const timer = setInterval(() => {
        current += increment;
        if (current >= target) {
          element.textContent = target + suffix;
          clearInterval(timer);
        } else {
          element.textContent = Math.floor(current) + suffix;
        }
      }, 16);
    }

    // Click sound effect
    function playClickSound() {
      // Ensure audio is initialized on first click
      if (!audioCtx) {
        try {
          initAudio();
        } catch (e) {
          return;
        }
      }

      if (!audioCtx) return;

      try {
        const oscillator = audioCtx.createOscillator();
        const gainNode = audioCtx.createGain();

        oscillator.connect(gainNode);
        gainNode.connect(audioCtx.destination);

        oscillator.frequency.value = 600;
        oscillator.type = 'square';

        gainNode.gain.setValueAtTime(0.08, audioCtx.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.05);

        oscillator.start(audioCtx.currentTime);
        oscillator.stop(audioCtx.currentTime + 0.05);
      } catch (e) {
        console.log('Audio not available');
      }
    }

    // Scroll sound effect
    let lastScrollTime = 0;
    const SCROLL_SOUND_THROTTLE = 80; // ms between scroll sounds (balanced)

    function playScrollSound(direction) {
      const now = Date.now();
      if (now - lastScrollTime < SCROLL_SOUND_THROTTLE) return;
      lastScrollTime = now;

      // Ensure audio is initialized
      if (!audioCtx) {
        try {
          initAudio();
        } catch (e) {
          return;
        }
      }

      if (!audioCtx) return;

      try {
        // Create a sharp click sound using white noise
        const bufferSize = audioCtx.sampleRate * 0.01; // 10ms of noise
        const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
        const data = buffer.getChannelData(0);

        // Generate white noise for click
        for (let i = 0; i < bufferSize; i++) {
          data[i] = Math.random() * 2 - 1;
        }

        const noise = audioCtx.createBufferSource();
        noise.buffer = buffer;

        const gainNode = audioCtx.createGain();
        const filter = audioCtx.createBiquadFilter();

        // High-pass filter for sharp click
        filter.type = 'highpass';
        filter.frequency.value = 2000;

        noise.connect(filter);
        filter.connect(gainNode);
        gainNode.connect(audioCtx.destination);

        // Very short, sharp envelope
        gainNode.gain.setValueAtTime(0.015, audioCtx.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.01);

        noise.start(audioCtx.currentTime);
        noise.stop(audioCtx.currentTime + 0.01);
      } catch (e) {
        console.log('Audio not available');
      }
    }

    // Track scroll direction and play sound
    let lastScrollY = window.scrollY;

    function handleScroll() {
      // Initialize audio on first scroll
      ensureAudioOnInteraction({ type: 'scroll' });

      const currentScrollY = window.scrollY;
      const direction = currentScrollY > lastScrollY ? 'down' : 'up';

      if (Math.abs(currentScrollY - lastScrollY) > 5) { // Play if scrolled more than 5px
        playScrollSound(direction);
      }

      lastScrollY = currentScrollY;
    }

    // Add scroll listener
    window.addEventListener('scroll', handleScroll, { passive: true });

    // Add click sound to all interactive elements
    function addClickSounds() {
      // Add to all buttons
      document.querySelectorAll('button, .refresh-btn, .export-btn, .sign-in-btn').forEach(btn => {
        btn.addEventListener('click', playClickSound);
      });

      // Add to all inputs on focus
      document.querySelectorAll('input, select, .filter-input').forEach(input => {
        input.addEventListener('focus', playClickSound);
      });

      // Add to table rows
      document.querySelectorAll('.users-table tbody tr').forEach(row => {
        row.addEventListener('click', playClickSound);
      });
    }

    // Check authentication
    document.addEventListener('DOMContentLoaded', () => {
      // Initialize audio immediately on page load
      try {
        initAudio();
        console.log('[DEBUG] Audio pre-initialized on page load');
      } catch (e) {
        console.log('[DEBUG] Audio pre-init failed (will retry on interaction):', e);
      }

      if (typeof firebase === 'undefined') {
        showError('Firebase not loaded');
        return;
      }

      adminAuth = window.firebaseAuth || firebase.auth();
      adminDb = window.firebaseDb || firebase.firestore();

      adminAuth.onAuthStateChanged((user) => {
        if (user) {
          // Check if user is admin (you can implement admin check here)
          checkAdminAccess(user);
        } else {
          showAuthRequired();
        }
      });
    });

    function showAuthRequired() {
      document.getElementById('authRequired').style.display = 'block';
      document.getElementById('dashboardContent').style.display = 'none';
    }

    // Global audio initialization on first interaction
    function ensureAudioOnInteraction(e) {
      if (!audioInitialized && !audioCtx) {
        try {
          initAudio();
          audioInitialized = true;
          console.log('[DEBUG] Audio initialized on user interaction:', e.type);

          // Remove all pending listeners
          const events = ['mousemove', 'click', 'keydown', 'touchstart', 'scroll'];
          events.forEach(eventType => {
            document.removeEventListener(eventType, ensureAudioOnInteraction);
          });
        } catch (e) {
          console.log('Audio initialization failed:', e);
        }
      }
    }

    function showDashboard() {
      document.getElementById('authRequired').style.display = 'none';
      document.getElementById('dashboardContent').style.display = 'block';

      const titleElement = document.getElementById('dashboardTitle');

      console.log('[DEBUG] Setting up audio initialization listeners...');
      console.log('[DEBUG] audioInitialized:', audioInitialized, 'audioCtx:', audioCtx);

      // Resume audio on first mousemove
      let audioResumed = false;
      let mouseMoveHandler = (e) => {
        if (!audioResumed && audioCtx) {
          console.log('[DEBUG] Mousemove - checking audio state:', audioCtx.state);
          if (audioCtx.state === 'suspended') {
            audioCtx.resume().then(() => {
              console.log('[DEBUG] Audio context RESUMED on mousemove');
              audioResumed = true;
            });
          } else {
            console.log('[DEBUG] Audio context already running:', audioCtx.state);
            audioResumed = true;
          }
          document.removeEventListener('mousemove', mouseMoveHandler);
        }
      };
      document.addEventListener('mousemove', mouseMoveHandler);

      // Backup click listener
      let clickHandler = (e) => {
        console.log('[DEBUG] Click detected!');
        if (!audioInitialized && !audioCtx) {
          try {
            initAudio();
            audioInitialized = true;
            console.log('[DEBUG] Audio initialized on click');
            document.removeEventListener('click', clickHandler);
          } catch (err) {
            console.log('[DEBUG] Audio init failed:', err);
          }
        }
      };
      document.addEventListener('click', clickHandler);

      // Start typewriter immediately (sounds will play once audio context is initialized)
      typewriterEffect(titleElement, 'User Analytics Dashboard', 80);

      loadDashboardData();
      loadDAUChart();
      loadExamAnalytics();
      // Add click sounds to buttons
      setTimeout(() => addClickSounds(), 100);

      // Auto-refresh DAU chart every 5 minutes to show updated hourly data
      setInterval(() => {
        console.log('[DAU] Auto-refreshing chart...');
        loadDAUChart();
      }, 5 * 60 * 1000); // 5 minutes
    }


    async function checkAdminAccess(user) {
      // For now, all authenticated users can access
      // In production, you'd check if user.email is in an admin list
      const adminEmails = ['alex@sheptech.co.uk', 'admin@example.com']; // Add your admin emails here

      // For development, allow all users
      showDashboard();

      // Uncomment for production:
      // if (adminEmails.includes(user.email)) {
      //   showDashboard();
      // } else {
      //   showError('You do not have admin access.');
      //   showAuthRequired();
      // }
    }

    function displayCachedDashboardData(cachedData) {
      const { stats } = cachedData;

      // Animate statistics with counter effect
      animateCounter(document.getElementById('totalUsers'), stats.totalUsers, 1200);
      animateCounter(document.getElementById('activeUsers'), stats.activeUsers, 1200);
      animateCounter(document.getElementById('totalSessions'), stats.totalSessions, 1400);
      animateCounter(document.getElementById('avgSessionTime'), stats.avgTime, 1000);

      // Display users
      displayUsers(allUsers);

      document.getElementById('loadingMessage').style.display = 'none';
      document.getElementById('usersTable').style.display = 'table';

      // Apply CRT flicker effect to stats
      document.querySelectorAll('.stat-card').forEach(card => {
        applyCRTFlicker(card);
      });

      // Add click sounds to table rows after they're rendered
      setTimeout(() => addClickSounds(), 100);
    }

    async function loadDashboardData(forceRefresh = false) {
      console.log('[DEBUG] ========== Starting Dashboard Load ==========');
      const startTime = performance.now();

      document.getElementById('loadingMessage').style.display = 'block';
      document.getElementById('loadingMessage').textContent = 'Loading users...';
      document.getElementById('usersTable').style.display = 'none';

      try {
        // Check cache first (unless force refresh)
        if (!forceRefresh) {
          const cachedData = getCachedData(CACHE_KEY_DASHBOARD);
          if (cachedData) {
            console.log('[DEBUG] Using cached dashboard data');
            allUsers = cachedData.users;

            // Display cached data immediately
            displayCachedDashboardData(cachedData);
            return;
          }
        }

        // Fetch all users
        console.log('[DEBUG] Fetching all users from Firestore...');
        const usersSnapshot = await adminDb.collection('users').get();
        console.log(`[DEBUG] Found ${usersSnapshot.size} users`);

        const now = new Date();
        const fiveMinutesAgo = new Date(now - 5 * 60 * 1000);

        // Process all users in parallel
        const userPromises = usersSnapshot.docs.map(async (doc) => {
          const userData = doc.data();

          // Skip admin users
          if (ADMIN_EMAILS.includes(userData.email)) {
            console.log(`[DEBUG] Skipping admin user: ${userData.email}`);
            return null;
          }

          // Get sessions for this user
          const sessionsSnapshot = await adminDb.collection('users').doc(doc.id)
            .collection('sessions').get();

          const sessionCount = sessionsSnapshot.size;

          // Check if user is currently active based on lastActive OR active sessions with recent heartbeats
          const lastActive = userData.lastActive?.toDate();
          let isActive = lastActive && lastActive > fiveMinutesAgo;

          // Also check for active sessions with recent heartbeats (more reliable)
          if (!isActive) {
            sessionsSnapshot.forEach(sessionDoc => {
              const session = sessionDoc.data();
              if (session.isActive && session.lastHeartbeat) {
                const lastHeartbeat = session.lastHeartbeat.toDate();
                const timeSinceHeartbeat = (now - lastHeartbeat) / 1000; // in seconds
                // Consider active if heartbeat was within last 2 minutes
                if (timeSinceHeartbeat < 120) {
                  isActive = true;
                }
              }
            });
          }

          // Calculate total session time
          let userTotalTime = 0;

          sessionsSnapshot.forEach(sessionDoc => {
            const session = sessionDoc.data();
            let duration = session.duration || 0;

            // For active sessions, use the stored duration (which is updated via heartbeat)
            // Only calculate real-time duration if the session was very recently active
            if (session.isActive && session.startTime) {
              const sessionStartTime = session.startTime.toDate();
              const lastHeartbeat = session.lastHeartbeat?.toDate() || sessionStartTime;
              const timeSinceHeartbeat = Math.floor((now - lastHeartbeat) / 1000);
              const timeSinceStart = Math.floor((now - sessionStartTime) / 1000);

              // Cap maximum session duration at 4 hours (14400 seconds)
              const MAX_SESSION_DURATION = 4 * 60 * 60;

              // If heartbeat was recent (within 2 minutes), add time since last heartbeat
              if (timeSinceHeartbeat < 120 && timeSinceStart < MAX_SESSION_DURATION) {
                duration = (session.duration || 0) + timeSinceHeartbeat;
              } else if (timeSinceHeartbeat >= 120 && timeSinceHeartbeat < 600) {
                // Session appears stale (2-10 minutes old), use stored duration only
                duration = session.duration || 0;
              } else {
                // Session is abandoned (>10 minutes since heartbeat), mark it for cleanup
                // For now, just use the stored duration and cap it
                duration = Math.min(session.duration || 0, MAX_SESSION_DURATION);

                // TODO: Mark this session as inactive in the database
                console.warn(`Session ${sessionDoc.id} appears abandoned (${Math.floor(timeSinceHeartbeat/60)}min since heartbeat)`);
              }

              // Apply max duration cap
              duration = Math.min(duration, MAX_SESSION_DURATION);
            } else if (session.endTime && session.startTime) {
              // For ended sessions, validate duration makes sense
              const sessionStartTime = session.startTime.toDate();
              const sessionEndTime = session.endTime.toDate();
              const calculatedDuration = Math.floor((sessionEndTime - sessionStartTime) / 1000);

              // Cap at 4 hours and use the smaller of stored or calculated
              const MAX_SESSION_DURATION = 4 * 60 * 60;
              duration = Math.min(session.duration || calculatedDuration, calculatedDuration, MAX_SESSION_DURATION);
            } else {
              // Session with no endTime and not active - cap it
              const MAX_SESSION_DURATION = 4 * 60 * 60;
              duration = Math.min(session.duration || 0, MAX_SESSION_DURATION);
            }

            // Final sanity check: no negative durations, no durations over 4 hours
            duration = Math.max(0, Math.min(duration, 4 * 60 * 60));

            if (duration > 0) {
              userTotalTime += duration;
            }
          });

          return {
            id: doc.id,
            email: userData.email,
            displayName: userData.displayName || 'N/A',
            lastSignIn: userData.lastSignIn?.toDate(),
            lastActive: lastActive,
            totalTimeSpent: userTotalTime,
            sessionCount: sessionCount,
            createdAt: userData.createdAt?.toDate(),
            isActive: isActive
          };
        });

        // Wait for all user data to be processed and filter out nulls (admin users)
        allUsers = (await Promise.all(userPromises)).filter(user => user !== null);

        // Calculate statistics
        let totalSessions = 0;
        let totalSessionTime = 0;
        let activeUsersCount = 0;

        allUsers.forEach(user => {
          totalSessions += user.sessionCount;
          totalSessionTime += user.totalTimeSpent;
          if (user.isActive) activeUsersCount++;
        });

        // Update statistics
        const endTime = performance.now();
        console.log('[DEBUG] ========== SUMMARY ==========');
        console.log(`[DEBUG] Total users: ${allUsers.length}`);
        console.log(`[DEBUG] Active users: ${activeUsersCount}`);
        console.log(`[DEBUG] Total sessions: ${totalSessions}`);
        console.log(`[DEBUG] Total session time: ${totalSessionTime}s (${Math.floor(totalSessionTime/60)}m)`);
        console.log(`[DEBUG] Average session time: ${totalSessions > 0 ? Math.round(totalSessionTime / totalSessions / 60) : 0}m`);
        console.log(`[DEBUG] Load time: ${Math.round(endTime - startTime)}ms`);
        console.log('[DEBUG] ==================================');

        // Animate statistics with counter effect
        animateCounter(document.getElementById('totalUsers'), allUsers.length, 1200);
        animateCounter(document.getElementById('activeUsers'), activeUsersCount, 1200);
        animateCounter(document.getElementById('totalSessions'), totalSessions, 1400);

        const avgTime = totalSessions > 0 ? Math.round(totalSessionTime / totalSessions / 60) : 0;
        animateCounter(document.getElementById('avgSessionTime'), avgTime, 1000);

        // Sort users by last active (most recent first)
        allUsers.sort((a, b) => {
          if (!a.lastActive) return 1;
          if (!b.lastActive) return -1;
          return b.lastActive - a.lastActive;
        });

        // Cache the data
        setCachedData(CACHE_KEY_DASHBOARD, {
          users: allUsers,
          stats: {
            totalUsers: allUsers.length,
            activeUsers: activeUsersCount,
            totalSessions: totalSessions,
            avgTime: avgTime
          },
          timestamp: Date.now()
        });

        // Display users
        displayUsers(allUsers);

        document.getElementById('loadingMessage').style.display = 'none';
        document.getElementById('usersTable').style.display = 'table';

        // Apply CRT flicker effect to stats
        document.querySelectorAll('.stat-card').forEach(card => {
          applyCRTFlicker(card);
        });

        // Play success chime when data loads
        playSuccessChime();

        // Add click sounds to table rows after they're rendered
        setTimeout(() => addClickSounds(), 100);

      } catch (error) {
        console.error('Error loading dashboard data:', error);
        showError('Error loading data: ' + error.message);
      }
    }

    function displayUsers(users) {
      const tbody = document.getElementById('usersTableBody');
      tbody.innerHTML = '';

      users.forEach(user => {
        const row = tbody.insertRow();

        // Status
        const statusCell = row.insertCell();
        const indicator = user.isActive ?
          '<span class="online-indicator"></span> Online' :
          '<span class="offline-indicator"></span> Offline';
        statusCell.innerHTML = indicator;

        // Email
        row.insertCell().textContent = user.email;

        // Name
        row.insertCell().textContent = user.displayName;

        // Last Sign In
        row.insertCell().textContent = formatDate(user.lastSignIn);

        // Last Active
        row.insertCell().textContent = formatRelativeTime(user.lastActive);

        // Total Time
        const timeCell = row.insertCell();
        timeCell.innerHTML = `<span class="time-badge">${formatDuration(user.totalTimeSpent)}</span>`;

        // Sessions
        const sessionsCell = row.insertCell();
        sessionsCell.innerHTML = `
          ${user.sessionCount}
          <div class="session-details">${user.totalTimeSpent > 0 ? formatDuration(user.totalTimeSpent / user.sessionCount) + ' avg' : ''}</div>
        `;

        // Joined
        row.insertCell().textContent = formatDate(user.createdAt);
      });
    }

    function filterUsers() {
      const searchTerm = document.getElementById('searchFilter').value.toLowerCase();
      const statusFilter = document.getElementById('statusFilter').value;

      let filtered = allUsers.filter(user => {
        // Search filter
        const matchesSearch = user.email.toLowerCase().includes(searchTerm) ||
                            user.displayName.toLowerCase().includes(searchTerm);

        // Status filter
        let matchesStatus = true;
        if (statusFilter === 'active') {
          matchesStatus = user.isActive;
        } else if (statusFilter === 'recent') {
          const oneDayAgo = new Date(Date.now() - 24 * 60 * 60 * 1000);
          matchesStatus = user.lastActive && user.lastActive > oneDayAgo;
        }

        return matchesSearch && matchesStatus;
      });

      displayUsers(filtered);
    }

    function formatDate(date) {
      if (!date) return 'Never';
      return new Date(date).toLocaleString('en-GB', {
        day: '2-digit',
        month: 'short',
        year: 'numeric',
        hour: '2-digit',
        minute: '2-digit'
      });
    }

    function formatRelativeTime(date) {
      if (!date) return 'Never';

      const now = new Date();
      const diff = now - new Date(date);
      const seconds = Math.floor(diff / 1000);
      const minutes = Math.floor(seconds / 60);
      const hours = Math.floor(minutes / 60);
      const days = Math.floor(hours / 24);

      if (seconds < 60) return 'Just now';
      if (minutes < 60) return `${minutes}m ago`;
      if (hours < 24) return `${hours}h ago`;
      if (days < 7) return `${days}d ago`;
      return formatDate(date);
    }

    function formatDuration(seconds) {
      if (!seconds || seconds < 0) return '0m';

      const hours = Math.floor(seconds / 3600);
      const minutes = Math.floor((seconds % 3600) / 60);

      if (hours > 0) {
        return `${hours}h ${minutes}m`;
      }
      return `${minutes}m`;
    }

    function exportToCSV() {
      const headers = ['Email', 'Name', 'Last Sign In', 'Last Active', 'Total Time (seconds)', 'Sessions', 'Joined'];
      const rows = allUsers.map(user => [
        user.email,
        user.displayName,
        user.lastSignIn ? user.lastSignIn.toISOString() : '',
        user.lastActive ? user.lastActive.toISOString() : '',
        user.totalTimeSpent,
        user.sessionCount,
        user.createdAt ? user.createdAt.toISOString() : ''
      ]);

      const csv = [headers, ...rows].map(row => row.join(',')).join('\n');
      const blob = new Blob([csv], { type: 'text/csv' });
      const url = window.URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `user-analytics-${new Date().toISOString().split('T')[0]}.csv`;
      a.click();
      window.URL.revokeObjectURL(url);
    }

    async function cleanupStaleSessions() {
      if (!confirm('This will mark all abandoned sessions as inactive and cap unrealistic durations. Continue?')) {
        return;
      }

      console.log('[CLEANUP] Starting stale session cleanup...');
      const now = new Date();
      const STALE_THRESHOLD = 10 * 60 * 1000; // 10 minutes
      const MAX_SESSION_DURATION = 4 * 60 * 60; // 4 hours in seconds

      try {
        let totalSessions = 0;
        let cleanedSessions = 0;

        // Get all users
        const usersSnapshot = await adminDb.collection('users').get();

        for (const userDoc of usersSnapshot.docs) {
          const userData = userDoc.data();

          // Skip admin users
          if (ADMIN_EMAILS.includes(userData.email)) {
            continue;
          }

          // Get all sessions for this user
          const sessionsSnapshot = await adminDb.collection('users')
            .doc(userDoc.id)
            .collection('sessions')
            .get();

          for (const sessionDoc of sessionsSnapshot.docs) {
            totalSessions++;
            const session = sessionDoc.data();
            let needsUpdate = false;
            const updates = {};

            // Check if session is marked as active but is stale
            if (session.isActive) {
              const lastHeartbeat = session.lastHeartbeat?.toDate() || session.startTime?.toDate();

              if (lastHeartbeat) {
                const timeSinceHeartbeat = now - lastHeartbeat;

                // If more than 10 minutes since last heartbeat, mark as inactive
                if (timeSinceHeartbeat > STALE_THRESHOLD) {
                  updates.isActive = false;
                  updates.endTime = lastHeartbeat; // Use last heartbeat as end time
                  needsUpdate = true;
                  console.log(`[CLEANUP] Marking session ${sessionDoc.id} as inactive (${Math.floor(timeSinceHeartbeat/1000/60)}min stale)`);
                }
              }
            }

            // Check if duration is unrealistic
            if (session.duration > MAX_SESSION_DURATION) {
              updates.duration = MAX_SESSION_DURATION;
              needsUpdate = true;
              console.log(`[CLEANUP] Capping session ${sessionDoc.id} duration from ${session.duration}s to ${MAX_SESSION_DURATION}s`);
            }

            // Validate duration against start/end times if available
            if (session.startTime && session.endTime) {
              const startTime = session.startTime.toDate();
              const endTime = session.endTime.toDate();
              const calculatedDuration = Math.floor((endTime - startTime) / 1000);

              // If stored duration is way off from calculated, use calculated (capped)
              if (Math.abs(session.duration - calculatedDuration) > 300) { // More than 5 min difference
                updates.duration = Math.min(calculatedDuration, MAX_SESSION_DURATION);
                needsUpdate = true;
                console.log(`[CLEANUP] Correcting session ${sessionDoc.id} duration from ${session.duration}s to ${updates.duration}s`);
              }
            }

            // Apply updates if needed
            if (needsUpdate) {
              await adminDb.collection('users')
                .doc(userDoc.id)
                .collection('sessions')
                .doc(sessionDoc.id)
                .update(updates);
              cleanedSessions++;
            }
          }
        }

        console.log(`[CLEANUP] Complete! Processed ${totalSessions} sessions, cleaned ${cleanedSessions}`);
        alert(`Cleanup complete!\n\nProcessed: ${totalSessions} sessions\nCleaned: ${cleanedSessions} sessions\n\nRefreshing dashboard...`);

        // Reload dashboard to show updated data
        loadDashboardData();

      } catch (error) {
        console.error('[CLEANUP] Error during cleanup:', error);
        alert('Error during cleanup: ' + error.message);
      }
    }


    let dauChart = null;

    async function loadDAUChart() {
      console.log('[DAU] Loading Daily Active Users chart...');
      document.getElementById('dauChartLoading').style.display = 'block';
      document.getElementById('dauChartContent').style.display = 'none';

      try {
        // Get admin user IDs to exclude
        const adminUserIds = [];
        const adminUsersSnapshot = await adminDb.collection('users')
          .where('email', 'in', ADMIN_EMAILS)
          .get();

        adminUsersSnapshot.forEach(doc => {
          adminUserIds.push(doc.id);
        });

        console.log('[DAU] Admin users to exclude:', adminUserIds);

        // Calculate date range - start from project inception (using AEST timezone)
        const now = new Date();

        // Convert UTC to AEST by adding timezone offset
        const nowAEST = new Date(now.getTime() + (TIMEZONE_OFFSET_HOURS * 60 * 60 * 1000));
        const todayAEST = new Date(Date.UTC(
          nowAEST.getUTCFullYear(),
          nowAEST.getUTCMonth(),
          nowAEST.getUTCDate(),
          23, 59, 59, 999
        ));

        // Set to project start date: November 6, 2025 (AEST)
        const startDate = new Date(Date.UTC(2025, 10, 6, 0, 0, 0, 0)); // Month is 0-indexed, so 10 = November

        console.log(`[DAU] Date range (${TIMEZONE_NAME}):`, startDate.toISOString().split('T')[0], 'to', todayAEST.toISOString().split('T')[0]);
        console.log('[DAU] Current time:', now.toISOString(), `(${TIMEZONE_NAME}: ${nowAEST.toISOString()})`);

        // Use the existing allUsers data if available from loadDashboardData
        // Otherwise fetch users fresh
        let usersToProcess = allUsers;

        if (!usersToProcess || usersToProcess.length === 0) {
          console.log('[DAU] No cached user data, fetching users...');
          const usersSnapshot = await adminDb.collection('users').get();
          usersToProcess = [];

          for (const doc of usersSnapshot.docs) {
            const userData = doc.data();
            if (!ADMIN_EMAILS.includes(userData.email)) {
              usersToProcess.push({
                id: doc.id,
                email: userData.email,
                displayName: userData.displayName || userData.email.split('@')[0]
              });
            }
          }
        }

        console.log('[DAU] Processing', usersToProcess.length, 'users...');

        // Process users in parallel for better performance - get ALL sessions
        const userPromises = usersToProcess.map(async (user) => {
          try {
            const sessionsSnapshot = await adminDb.collection('users')
              .doc(user.id)
              .collection('sessions')
              .get();

            console.log(`[DAU] User ${user.email}: ${sessionsSnapshot.size} sessions found`);

            const userSessions = [];
            sessionsSnapshot.forEach(sessionDoc => {
              const session = sessionDoc.data();
              console.log(`[DAU] Session data for ${user.email}:`, session);

              if (session.startTime) {
                const sessionDate = session.startTime.toDate();
                console.log(`[DAU] Adding session for ${user.email} on ${sessionDate.toISOString()}`);
                userSessions.push({
                  date: sessionDate,
                  userId: user.id,
                  email: user.email,
                  displayName: user.displayName,
                  duration: session.duration || 0
                });
              } else {
                console.warn(`[DAU] Session missing startTime for ${user.email}:`, session);
              }
            });

            return userSessions;
          } catch (error) {
            console.error(`[DAU] Error fetching sessions for user ${user.email}:`, error);
            return [];
          }
        });

        // Wait for all user sessions to be fetched
        const allSessionsArrays = await Promise.all(userPromises);
        const allSessions = allSessionsArrays.flat();

        console.log('[DAU] Fetched', allSessions.length, 'total sessions');

        // Build dauData with the date range from Nov 6, 2025 to today (inclusive)
        const dauData = {};

        // Helper function to get date key in YYYY-MM-DD format (AEST timezone)
        function getAESTDateKey(date) {
          // Convert UTC timestamp to AEST
          const aestDate = new Date(date.getTime() + (TIMEZONE_OFFSET_HOURS * 60 * 60 * 1000));
          const year = aestDate.getUTCFullYear();
          const month = String(aestDate.getUTCMonth() + 1).padStart(2, '0');
          const day = String(aestDate.getUTCDate()).padStart(2, '0');
          return `${year}-${month}-${day}`;
        }

        // Calculate number of days between start and today (using AEST)
        const msPerDay = 24 * 60 * 60 * 1000;
        const startDateOnly = new Date(Date.UTC(startDate.getUTCFullYear(), startDate.getUTCMonth(), startDate.getUTCDate()));
        const todayDateOnly = new Date(Date.UTC(todayAEST.getUTCFullYear(), todayAEST.getUTCMonth(), todayAEST.getUTCDate()));
        const daysDiff = Math.floor((todayDateOnly - startDateOnly) / msPerDay);

        // Create a bucket for each day including today (using AEST)
        for (let i = 0; i <= daysDiff; i++) {
          const d = new Date(startDateOnly.getTime() + (i * msPerDay));
          const dateKey = getAESTDateKey(d);
          dauData[dateKey] = {
            count: 0,
            users: new Set(),
            userDetails: []
          };
        }

        console.log('[DAU] Created', Object.keys(dauData).length, 'days from', getAESTDateKey(startDateOnly), 'to', getAESTDateKey(todayDateOnly));
        console.log('[DAU] Date keys:', Object.keys(dauData));

        // Process sessions into daily buckets (converting Firebase UTC timestamps to AEST)
        allSessions.forEach(session => {

          const dateKey = getAESTDateKey(session.date);

          if (dauData[dateKey]) {
            // Add user to this day if not already added
            if (!dauData[dateKey].users.has(session.userId)) {
              dauData[dateKey].users.add(session.userId);
              dauData[dateKey].count++;
              dauData[dateKey].userDetails.push({
                userId: session.userId,
                email: session.email,
                displayName: session.displayName,
                totalTime: session.duration
              });
            } else {
              // User already exists for this day, add to their total time
              const userDetail = dauData[dateKey].userDetails.find(u => u.userId === session.userId);
              if (userDetail) {
                userDetail.totalTime = (userDetail.totalTime || 0) + session.duration;
              }
            }
          }
        });

        // Convert to arrays for Chart.js
        const dates = Object.keys(dauData).sort();
        const counts = dates.map(date => dauData[date].count);
        const userDetails = dates.map(date => dauData[date].userDetails);

        // Calculate cumulative total users by counting users created up to each date
        const cumulativeCounts = [];
        let totalUsersByDate = 0;

        // Get all users with their creation dates
        const usersSnapshot = await adminDb.collection('users').get();
        const userCreationDates = [];

        usersSnapshot.forEach(doc => {
          const userData = doc.data();
          if (!ADMIN_EMAILS.includes(userData.email) && userData.createdAt) {
            userCreationDates.push(userData.createdAt.toDate());
          }
        });

        // Sort creation dates
        userCreationDates.sort((a, b) => a - b);

        // For each date in our range, count how many users existed by then
        dates.forEach(dateKey => {
          const date = new Date(dateKey);
          date.setHours(23, 59, 59, 999); // End of day

          const usersCreatedByThisDate = userCreationDates.filter(createdDate => createdDate <= date).length;
          cumulativeCounts.push(usersCreatedByThisDate);
        });

        console.log('[DAU] Chart data ready:', { totalDays: dates.length, dates: dates.slice(0, 5), counts: counts.slice(0, 5), cumulativeCounts: cumulativeCounts.slice(0, 5) });

        // Create the chart
        createDAUChart(dates, counts, userDetails, cumulativeCounts);

        document.getElementById('dauChartLoading').style.display = 'none';
        document.getElementById('dauChartContent').style.display = 'block';

      } catch (error) {
        console.error('[DAU] Error loading DAU chart:', error);
        document.getElementById('dauChartLoading').textContent = 'Error loading DAU chart: ' + error.message;
      }
    }

    function createDAUChart(dates, counts, userDetails, cumulativeCounts) {
      const ctx = document.getElementById('dauChart');
      const container = document.getElementById('dauChartContainer');
      if (!ctx || !container) return;

      // Destroy existing chart if it exists
      if (dauChart) {
        dauChart.destroy();
      }

      // Calculate width based on number of days (30px per day for readability)
      const totalDays = dates.length;
      const pixelsPerDay = 30;
      const chartWidth = Math.max(totalDays * pixelsPerDay, container.parentElement.offsetWidth);

      // Set canvas width
      container.style.width = chartWidth + 'px';
      ctx.width = chartWidth;

      console.log('[DAU] Chart dimensions:', { totalDays, chartWidth });

      // Format dates for display (e.g., "Nov 19")
      const labels = dates.map(date => {
        const d = new Date(date);
        return d.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
      });

      // Create custom plugin for crosshair lines on hover
      const crosshairPlugin = {
        id: 'crosshair',
        afterDatasetsDraw(chart, args, options) {
          const { ctx, chartArea: { top, bottom, left, right }, tooltip } = chart;

          if (tooltip && tooltip._active && tooltip._active.length) {
            const activePoint = tooltip._active[0];
            const x = activePoint.element.x;
            const y = activePoint.element.y;

            ctx.save();

            // Draw horizontal line
            ctx.beginPath();
            ctx.moveTo(left, y);
            ctx.lineTo(right, y);
            ctx.lineWidth = 1;
            ctx.strokeStyle = 'rgba(0, 255, 136, 0.5)';
            ctx.setLineDash([5, 5]);
            ctx.stroke();

            // Draw vertical line
            ctx.beginPath();
            ctx.moveTo(x, top);
            ctx.lineTo(x, bottom);
            ctx.lineWidth = 1;
            ctx.strokeStyle = 'rgba(0, 255, 136, 0.5)';
            ctx.setLineDash([5, 5]);
            ctx.stroke();

            ctx.restore();
          }
        }
      };

      dauChart = new Chart(ctx, {
        type: 'line',
        data: {
          labels: labels,
          datasets: [{
            label: 'Daily Active Users',
            data: counts,
            borderColor: '#00ff88',
            backgroundColor: 'rgba(0, 255, 136, 0.1)',
            borderWidth: 2,
            fill: true,
            tension: 0.3,
            pointRadius: 4,
            pointHoverRadius: 6,
            pointBackgroundColor: '#00ff88',
            pointBorderColor: '#0a0e0a',
            pointBorderWidth: 2,
            pointHoverBackgroundColor: '#00ff88',
            pointHoverBorderColor: '#fff',
            pointHoverBorderWidth: 2,
            yAxisID: 'y'
          }, {
            label: 'Total Users',
            data: cumulativeCounts,
            borderColor: '#a855f7',
            backgroundColor: 'rgba(168, 85, 247, 0.1)',
            borderWidth: 2,
            fill: false,
            tension: 0.3,
            pointRadius: 4,
            pointHoverRadius: 6,
            pointBackgroundColor: '#a855f7',
            pointBorderColor: '#0a0e0a',
            pointBorderWidth: 2,
            pointHoverBackgroundColor: '#a855f7',
            pointHoverBorderColor: '#fff',
            pointHoverBorderWidth: 2,
            yAxisID: 'y'
          }]
        },
        options: {
          responsive: false,
          maintainAspectRatio: false,
          interaction: {
            mode: 'index',
            intersect: false
          },
          onHover: function(event, activeElements) {
            const userListDiv = document.getElementById('dauUserList');
            if (!userListDiv) return;

            if (activeElements && activeElements.length > 0) {
              const dataIndex = activeElements[0].index;
              const date = dates[dataIndex];
              const count = counts[dataIndex];
              const users = userDetails[dataIndex];

              // Format date nicely
              const dateObj = new Date(date);
              const formattedDate = dateObj.toLocaleDateString('en-US', {
                weekday: 'long',
                year: 'numeric',
                month: 'long',
                day: 'numeric'
              });

              // Build user list HTML - compact version
              let html = `
                <div style="margin-bottom: 12px; padding-bottom: 8px; border-bottom: 1px solid rgba(0, 255, 136, 0.2);">
                  <div style="color: #00ff88; font-weight: 600; font-size: 0.85em;">${formattedDate.split(',')[0]}, ${dateObj.toLocaleDateString('en-US', { month: 'short', day: 'numeric' })}</div>
                  <div style="color: #ccc; font-size: 0.75em; margin-top: 2px;">${count} active user${count !== 1 ? 's' : ''}</div>
                </div>
              `;

              if (users && users.length > 0) {
                html += '<div style="display: flex; flex-direction: column; gap: 4px;">';
                users.forEach(user => {
                  // Format time - convert seconds to minutes
                  // Cap at 12 hours per day (43200 seconds) to handle legacy bad data
                  const MAX_DAILY_SECONDS = 12 * 60 * 60;
                  const cappedTime = Math.min(user.totalTime || 0, MAX_DAILY_SECONDS);
                  const minutes = Math.round(cappedTime / 60);
                  const timeDisplay = minutes >= 60
                    ? `${Math.floor(minutes / 60)}h ${minutes % 60}m`
                    : `${minutes}m`;

                  html += `
                    <div style="padding: 4px 8px; background: rgba(0, 255, 136, 0.05); border-left: 2px solid #00ff88; border-radius: 3px; display: flex; justify-content: space-between; align-items: center;">
                      <div style="flex: 1; min-width: 0;">
                        <div style="color: #00ff88; font-weight: 500; font-size: 0.8em;">${user.displayName}</div>
                        <div style="color: #888; font-size: 0.7em; margin-top: 1px;">${user.email}</div>
                      </div>
                      <div style="color: #00ff88; font-size: 0.75em; font-weight: 600; margin-left: 8px; white-space: nowrap;">${timeDisplay}</div>
                    </div>
                  `;
                });
                html += '</div>';
              } else {
                html += '<p style="margin: 0; color: #666; font-style: italic; font-size: 0.85em;">No users active on this day</p>';
              }

              userListDiv.innerHTML = html;
            } else {
              // Reset to default message when not hovering
              userListDiv.innerHTML = '<p style="margin: 0; padding: 20px 0; text-align: center;">Hover over the chart to see active users for that day</p>';
            }
          },
          plugins: {
            legend: {
              display: false
            },
            tooltip: {
              backgroundColor: 'rgba(0, 0, 0, 0.9)',
              titleColor: '#00ff88',
              bodyColor: '#ccc',
              borderColor: '#00ff88',
              borderWidth: 1,
              padding: 16,
              displayColors: true,
              callbacks: {
                title: function(context) {
                  const dateIndex = context[0].dataIndex;
                  return dates[dateIndex];
                },
                label: function(context) {
                  if (context.datasetIndex === 0) {
                    return `Active Users: ${context.parsed.y}`;
                  } else {
                    return `Total Users: ${context.parsed.y}`;
                  }
                },
                afterLabel: function(context) {
                  // Only show user details for DAU (first dataset)
                  if (context.datasetIndex === 0) {
                    const dateIndex = context.dataIndex;
                    const users = userDetails[dateIndex];

                    if (users && users.length > 0) {
                      const userList = users.map(u => `  ‚Ä¢ ${u.displayName} (${u.email})`);
                      return ['\nUsers:', ...userList];
                    }
                  }
                  return '';
                }
              }
            }
          },
          scales: {
            x: {
              ticks: {
                color: '#888',
                font: {
                  family: "'JetBrains Mono', monospace",
                  size: 10
                },
                maxRotation: 45,
                minRotation: 45
              },
              grid: {
                color: 'rgba(0, 255, 136, 0.1)'
              }
            },
            y: {
              beginAtZero: true,
              ticks: {
                color: '#00ff88',
                font: {
                  family: "'JetBrains Mono', monospace",
                  size: 11
                },
                stepSize: 1
              },
              grid: {
                color: 'rgba(0, 255, 136, 0.1)'
              }
            }
          }
        },
        plugins: [crosshairPlugin]
      });

      console.log('[DAU] Chart created successfully');

      // Scroll to show the last 30 days (most recent data)
      setTimeout(() => {
        const scrollContainer = container.parentElement;
        if (scrollContainer) {
          // Calculate scroll position to show last 30 days
          const daysToShow = 30;
          const scrollPosition = Math.max(0, chartWidth - (daysToShow * pixelsPerDay));
          scrollContainer.scrollLeft = scrollPosition;
          console.log('[DAU] Scrolled to position:', scrollPosition, 'to show last', daysToShow, 'days');
        }
      }, 100);
    }

    async function resetAllSessionData() {
      const confirmMessage = `‚ö†Ô∏è WARNING: This will DELETE all session data and reset total time to 0 for all users.

This is useful after fixing the tracking system to start fresh with accurate data.

Are you absolutely sure you want to continue?`;

      if (!confirm(confirmMessage)) {
        return;
      }

      // Double confirmation
      if (!confirm('This action CANNOT be undone. Click OK to proceed.')) {
        return;
      }

      console.log('[RESET] Starting complete session data reset...');

      try {
        let totalUsers = 0;
        let totalSessionsDeleted = 0;

        // Get all users
        const usersSnapshot = await adminDb.collection('users').get();

        for (const userDoc of usersSnapshot.docs) {
          totalUsers++;
          const userData = userDoc.data();

          console.log(`[RESET] Processing user: ${userData.email}`);

          // Delete all sessions for this user
          const sessionsSnapshot = await adminDb.collection('users')
            .doc(userDoc.id)
            .collection('sessions')
            .get();

          const batch = adminDb.batch();
          let sessionCount = 0;

          sessionsSnapshot.forEach(sessionDoc => {
            batch.delete(sessionDoc.ref);
            sessionCount++;
          });

          // Commit session deletions
          if (sessionCount > 0) {
            await batch.commit();
            totalSessionsDeleted += sessionCount;
            console.log(`[RESET] Deleted ${sessionCount} sessions for ${userData.email}`);
          }

          // Reset user's time statistics
          await adminDb.collection('users').doc(userDoc.id).update({
            totalTimeSpent: 0
          });
        }

        console.log(`[RESET] Complete! Reset ${totalUsers} users and deleted ${totalSessionsDeleted} sessions`);
        alert(`‚úÖ Session data reset complete!\n\nUsers processed: ${totalUsers}\nSessions deleted: ${totalSessionsDeleted}\n\nAll users now start with 0 total time. New sessions will be tracked accurately.\n\nRefreshing dashboard...`);

        // Reload dashboard to show updated data
        loadDashboardData();
        loadDAUChart();

      } catch (error) {
        console.error('[RESET] Error during reset:', error);
        alert('‚ùå Error during reset: ' + error.message);
      }
    }

    async function resetAnalyticsData() {
      const confirmMessage = `‚ö†Ô∏è WARNING: This will DELETE all analytics tracking data including:

‚Ä¢ All case view analytics (caseAnalytics collection)
‚Ä¢ All exam view analytics (examAnalytics collection)
‚Ä¢ Journey/navigation tracking data

This will NOT delete user sessions or session time data.

Are you absolutely sure you want to continue?`;

      if (!confirm(confirmMessage)) {
        return;
      }

      // Double confirmation
      if (!confirm('This action CANNOT be undone. Click OK to proceed.')) {
        return;
      }

      console.log('[RESET-ANALYTICS] Starting analytics data reset...');

      try {
        let caseAnalyticsDeleted = 0;
        let examAnalyticsDeleted = 0;

        // Delete all caseAnalytics documents
        console.log('[RESET-ANALYTICS] Deleting caseAnalytics collection...');
        const caseAnalyticsSnapshot = await adminDb.collection('caseAnalytics').get();

        const caseBatch = adminDb.batch();
        caseAnalyticsSnapshot.forEach(doc => {
          caseBatch.delete(doc.ref);
          caseAnalyticsDeleted++;
        });

        if (caseAnalyticsDeleted > 0) {
          await caseBatch.commit();
          console.log(`[RESET-ANALYTICS] Deleted ${caseAnalyticsDeleted} case analytics documents`);
        }

        // Delete all examAnalytics documents
        console.log('[RESET-ANALYTICS] Deleting examAnalytics collection...');
        const examAnalyticsSnapshot = await adminDb.collection('examAnalytics').get();

        const examBatch = adminDb.batch();
        examAnalyticsSnapshot.forEach(doc => {
          examBatch.delete(doc.ref);
          examAnalyticsDeleted++;
        });

        if (examAnalyticsDeleted > 0) {
          await examBatch.commit();
          console.log(`[RESET-ANALYTICS] Deleted ${examAnalyticsDeleted} exam analytics documents`);
        }

        console.log(`[RESET-ANALYTICS] Complete!`);
        alert(`‚úÖ Analytics data reset complete!\n\nCase analytics deleted: ${caseAnalyticsDeleted}\nExam analytics deleted: ${examAnalyticsDeleted}\n\nAll analytics tracking will start fresh from now.\n\nRefreshing dashboard...`);

        // Reload dashboard to show updated data
        loadExamAnalytics();

      } catch (error) {
        console.error('[RESET-ANALYTICS] Error during reset:', error);
        alert('‚ùå Error during analytics reset: ' + error.message);
      }
    }

    async function checkSessionHealth() {
      console.log('[SESSION-CHECK] Starting session health diagnostic...');

      try {
        const usersSnapshot = await adminDb.collection('users').get();
        const results = {
          totalUsers: 0,
          usersWithSessions: 0,
          usersWithoutSessions: 0,
          usersWithoutCreatedAt: 0,
          recentUsersWithoutSessions: 0,
          oldUsersWithoutSessions: 0,
          usersMissingData: []
        };

        const now = new Date();
        const sevenDaysAgo = new Date(now - 7 * 24 * 60 * 60 * 1000);

        for (const userDoc of usersSnapshot.docs) {
          const userData = userDoc.data();

          // Skip admin users
          if (ADMIN_EMAILS.includes(userData.email)) {
            continue;
          }

          results.totalUsers++;

          // Check for createdAt
          if (!userData.createdAt) {
            results.usersWithoutCreatedAt++;
          }

          // Check for sessions
          const sessionsSnapshot = await adminDb.collection('users')
            .doc(userDoc.id)
            .collection('sessions')
            .get();

          if (sessionsSnapshot.size === 0) {
            results.usersWithoutSessions++;

            const lastSignIn = userData.lastSignIn?.toDate();
            const isRecent = lastSignIn && lastSignIn > sevenDaysAgo;

            if (isRecent) {
              results.recentUsersWithoutSessions++;
            } else {
              results.oldUsersWithoutSessions++;
            }

            results.usersMissingData.push({
              email: userData.email,
              displayName: userData.displayName,
              createdAt: userData.createdAt ? userData.createdAt.toDate().toISOString() : 'MISSING',
              lastSignIn: userData.lastSignIn ? userData.lastSignIn.toDate().toISOString() : 'NEVER',
              isRecent: isRecent
            });
          } else {
            results.usersWithSessions++;
          }
        }

        // Sort by most recent first
        results.usersMissingData.sort((a, b) => {
          if (a.lastSignIn === 'NEVER') return 1;
          if (b.lastSignIn === 'NEVER') return -1;
          return new Date(b.lastSignIn) - new Date(a.lastSignIn);
        });

        console.log('[SESSION-CHECK] ========== RESULTS ==========');
        console.log('[SESSION-CHECK] Total users (excluding admins):', results.totalUsers);
        console.log('[SESSION-CHECK] Users WITH sessions:', results.usersWithSessions);
        console.log('[SESSION-CHECK] Users WITHOUT sessions:', results.usersWithoutSessions);
        console.log('[SESSION-CHECK]   - Active in last 7 days:', results.recentUsersWithoutSessions);
        console.log('[SESSION-CHECK]   - Inactive (>7 days):', results.oldUsersWithoutSessions);
        console.log('[SESSION-CHECK] Users without createdAt:', results.usersWithoutCreatedAt);
        console.log('[SESSION-CHECK] Users missing session data (sorted by recency):', results.usersMissingData);
        console.log('[SESSION-CHECK] ====================================');

        const alertMessage = `Session Health Check:\n\nTotal Users: ${results.totalUsers}\nWith Sessions: ${results.usersWithSessions} (${Math.round(results.usersWithSessions/results.totalUsers*100)}%)\nWithout Sessions: ${results.usersWithoutSessions}\n\n‚ö†Ô∏è Recent users without sessions: ${results.recentUsersWithoutSessions}\n(These should have sessions!)\n\nOld inactive users: ${results.oldUsersWithoutSessions}\n\nCheck console for detailed list.`;

        alert(alertMessage);

        return results;

      } catch (error) {
        console.error('[SESSION-CHECK] Error:', error);
        alert('Error running session health check: ' + error.message);
      }
    }

    async function createRetroactiveSessions() {
      if (!confirm('‚ö†Ô∏è This will create initial sessions for users who don\'t have any.\n\nThis helps populate the DAU chart with historical data based on lastSignIn timestamps.\n\nContinue?')) {
        return;
      }

      console.log('[RETROACTIVE] Starting retroactive session creation...');

      try {
        const healthCheck = await checkSessionHealth();

        if (!healthCheck || healthCheck.usersMissingData.length === 0) {
          alert('No users need retroactive sessions!');
          return;
        }

        let created = 0;
        let skipped = 0;
        let errors = 0;

        for (const user of healthCheck.usersMissingData) {
          try {
            // Skip users who never signed in
            if (user.lastSignIn === 'NEVER') {
              skipped++;
              continue;
            }

            // Find user document
            const usersSnapshot = await adminDb.collection('users')
              .where('email', '==', user.email)
              .limit(1)
              .get();

            if (usersSnapshot.empty) {
              console.error('[RETROACTIVE] User not found:', user.email);
              errors++;
              continue;
            }

            const userDoc = usersSnapshot.docs[0];
            const userData = userDoc.data();
            const userId = userDoc.id;

            // Create a session based on lastSignIn
            const lastSignInDate = new Date(user.lastSignIn);

            await adminDb.collection('users').doc(userId).collection('sessions').add({
              startTime: firebase.firestore.Timestamp.fromDate(lastSignInDate),
              endTime: firebase.firestore.Timestamp.fromDate(lastSignInDate),
              duration: 0,
              pages: [{
                path: '/',
                title: 'Home',
                timestamp: lastSignInDate
              }],
              isActive: false,
              userAgent: 'Retroactive Session Creation',
              platform: 'Admin Tool',
              retroactive: true
            });

            console.log(`[RETROACTIVE] Created session for ${user.email} on ${user.lastSignIn}`);
            created++;

          } catch (error) {
            console.error(`[RETROACTIVE] Error creating session for ${user.email}:`, error);
            errors++;
          }
        }

        console.log('[RETROACTIVE] ========== SUMMARY ==========');
        console.log('[RETROACTIVE] Sessions created:', created);
        console.log('[RETROACTIVE] Users skipped (never signed in):', skipped);
        console.log('[RETROACTIVE] Errors:', errors);

        alert(`‚úÖ Retroactive Session Creation Complete!\n\nCreated: ${created} sessions\nSkipped: ${skipped} (never signed in)\nErrors: ${errors}\n\nRefreshing dashboard...`);

        // Clear cache and reload
        clearAllCaches();
        loadDashboardData(true);
        loadDAUChart();

      } catch (error) {
        console.error('[RETROACTIVE] Error:', error);
        alert('Error creating retroactive sessions: ' + error.message);
      }
    }

    async function resetEverything() {
      const confirmMessage = `üö® NUCLEAR OPTION: This will DELETE EVERYTHING:

‚Ä¢ All session data
‚Ä¢ All user time statistics
‚Ä¢ All case analytics
‚Ä¢ All exam analytics
‚Ä¢ All journey/navigation data

This gives you a completely clean slate.

Are you ABSOLUTELY CERTAIN you want to do this?`;

      if (!confirm(confirmMessage)) {
        return;
      }

      // Triple confirmation for nuclear option
      if (!confirm('FINAL WARNING: This deletes ALL analytics and session data. Continue?')) {
        return;
      }

      console.log('[RESET-ALL] Starting complete data wipe...');

      try {
        // First reset sessions
        await resetAllSessionData();

        // Wait a moment
        await new Promise(resolve => setTimeout(resolve, 1000));

        // Then reset analytics
        await resetAnalyticsData();

        console.log(`[RESET-ALL] Complete nuclear reset finished!`);
        alert(`‚úÖ Complete reset finished!\n\nAll data has been wiped clean.\n\nRefreshing entire dashboard...`);

        // Reload everything
        loadDashboardData();
        loadDAUChart();
        loadExamAnalytics();

      } catch (error) {
        console.error('[RESET-ALL] Error during complete reset:', error);
        alert('‚ùå Error during complete reset: ' + error.message);
      }
    }

    function showError(message) {
      const errorDiv = document.getElementById('errorMessage');
      errorDiv.textContent = message;
      errorDiv.style.display = 'block';
      setTimeout(() => {
        errorDiv.style.display = 'none';
      }, 5000);
    }

    // Matrix Rain Effect
    function initMatrixRain() {
      const canvas = document.getElementById('matrixCanvas');
      const ctx = canvas.getContext('2d');

      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;

      const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789@#$%^&*()';
      const fontSize = 14;
      const columns = canvas.width / fontSize;
      const drops = [];

      // Initialize drops
      for (let i = 0; i < columns; i++) {
        drops[i] = Math.random() * -100;
      }

      function draw() {
        // Fade effect
        ctx.fillStyle = 'rgba(10, 14, 10, 0.05)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        ctx.fillStyle = '#00ff88';
        ctx.font = fontSize + 'px monospace';

        for (let i = 0; i < drops.length; i++) {
          const text = chars[Math.floor(Math.random() * chars.length)];
          ctx.fillText(text, i * fontSize, drops[i] * fontSize);

          if (drops[i] * fontSize > canvas.height && Math.random() > 0.975) {
            drops[i] = 0;
          }

          drops[i]++;
        }
      }

      setInterval(draw, 35);

      // Resize handler
      window.addEventListener('resize', () => {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
      });
    }

    // Success chime sound (plays when data loads successfully)
    function playSuccessChime() {
      if (!audioCtx) {
        try {
          initAudio();
        } catch (e) {
          return;
        }
      }
      if (!audioCtx) return;

      try {
        // Create a pleasant upward arpeggio
        const frequencies = [523.25, 659.25, 783.99]; // C5, E5, G5
        frequencies.forEach((freq, index) => {
          setTimeout(() => {
            const oscillator = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();

            oscillator.connect(gainNode);
            gainNode.connect(audioCtx.destination);

            oscillator.frequency.value = freq;
            oscillator.type = 'sine';

            gainNode.gain.setValueAtTime(0.1, audioCtx.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.3);

            oscillator.start(audioCtx.currentTime);
            oscillator.stop(audioCtx.currentTime + 0.3);
          }, index * 100);
        });
      } catch (e) {
        console.log('Audio not available');
      }
    }

    // Alert beep sound (for new activity)
    function playAlertBeep() {
      if (!audioCtx) {
        try {
          initAudio();
        } catch (e) {
          return;
        }
      }
      if (!audioCtx) return;

      try {
        const oscillator = audioCtx.createOscillator();
        const gainNode = audioCtx.createGain();

        oscillator.connect(gainNode);
        gainNode.connect(audioCtx.destination);

        // Double beep
        oscillator.frequency.value = 880; // A5
        oscillator.type = 'square';

        gainNode.gain.setValueAtTime(0.08, audioCtx.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);

        oscillator.start(audioCtx.currentTime);
        oscillator.stop(audioCtx.currentTime + 0.1);

        // Second beep
        setTimeout(() => {
          const oscillator2 = audioCtx.createOscillator();
          const gainNode2 = audioCtx.createGain();

          oscillator2.connect(gainNode2);
          gainNode2.connect(audioCtx.destination);

          oscillator2.frequency.value = 880;
          oscillator2.type = 'square';

          gainNode2.gain.setValueAtTime(0.08, audioCtx.currentTime);
          gainNode2.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);

          oscillator2.start(audioCtx.currentTime);
          oscillator2.stop(audioCtx.currentTime + 0.1);
        }, 150);
      } catch (e) {
        console.log('Audio not available');
      }
    }

    // CRT Flicker effect on data refresh
    function applyCRTFlicker(element) {
      element.classList.add('crt-flicker');
      setTimeout(() => {
        element.classList.remove('crt-flicker');
      }, 150);
    }

    // Matrix rain disabled for readability
    // if (document.readyState === 'loading') {
    //   document.addEventListener('DOMContentLoaded', initMatrixRain);
    // } else {
    //   initMatrixRain();
    // }


    // Admin favicon roulette spin on hover
    document.addEventListener('DOMContentLoaded', () => {
      const favicon = document.getElementById('adminFavicon');
      if (favicon) {
        favicon.addEventListener('mouseenter', () => {
          // Remove the class if it exists (to allow re-triggering)
          favicon.classList.remove('spinning');
          // Force reflow to restart animation
          void favicon.offsetWidth;
          // Add the spinning class
          favicon.classList.add('spinning');
        });

        // Remove the class after animation completes to allow re-triggering
        favicon.addEventListener('animationend', () => {
          favicon.classList.remove('spinning');
        });
      }
    });

    // ========== EXAM ANALYTICS ==========
    async function loadExamAnalytics() {
      console.log('[Exam] Loading exam analytics...');
      document.getElementById('examLoading').style.display = 'block';
      document.getElementById('examContent').style.display = 'none';

      try {
        // Get all exam analytics
        const examSnapshot = await adminDb.collection('examAnalytics').get();

        let totalViews = 0;
        const uniqueViewersSet = new Set();
        const examData = [];
        let mostPopular = { title: 'N/A', views: 0 };

        examSnapshot.forEach(doc => {
          const data = doc.data();

          // Skip OSCE timer data as requested
          if (data.type === 'osce-timer' || data.resourceId?.includes('osce-timer')) {
            console.log('[Exam] Skipping OSCE timer:', data.resourceId);
            return;
          }

          totalViews += data.viewCount || 0;

          // Add unique viewers to set
          if (data.uniqueViewers && Array.isArray(data.uniqueViewers)) {
            data.uniqueViewers.forEach(uid => uniqueViewersSet.add(uid));
          }

          // Track most popular
          if ((data.viewCount || 0) > mostPopular.views) {
            mostPopular = {
              title: data.title || data.resourceId,
              views: data.viewCount || 0
            };
          }

          examData.push({
            id: doc.id,
            ...data
          });
        });

        // Update stats
        animateCounter(document.getElementById('totalExamViews'), totalViews, 1200);
        animateCounter(document.getElementById('uniqueExamViewers'), uniqueViewersSet.size, 1200);
        document.getElementById('mostPopularExam').textContent = mostPopular.title;

        // Display exam table
        displayExamTable(examData);

        document.getElementById('examLoading').style.display = 'none';
        document.getElementById('examContent').style.display = 'block';

      } catch (error) {
        console.error('[Exam] Error loading exam analytics:', error);
        document.getElementById('examLoading').textContent = 'Error loading exam analytics: ' + error.message;
      }
    }

    function displayExamTable(examData) {
      const tbody = document.getElementById('examTableBody');
      tbody.innerHTML = '';

      // Sort by view count (descending)
      examData.sort((a, b) => (b.viewCount || 0) - (a.viewCount || 0));

      examData.forEach(exam => {
        const row = tbody.insertRow();

        // Resource name
        const nameCell = row.insertCell();
        nameCell.innerHTML = `
          <div style="font-weight: 600;">${exam.title || exam.resourceId}</div>
          <div style="color: #666; font-size: 0.85em;">${exam.resourceId}</div>
        `;

        // Type
        const typeCell = row.insertCell();
        const typeColors = {
          'saq': '#00ff88',
          'mcq': '#a855f7',
          'exam': '#3b82f6'
        };
        const typeColor = typeColors[exam.type] || '#888';
        typeCell.innerHTML = `<span style="color: ${typeColor}; font-weight: 500;">${(exam.type || 'exam').toUpperCase()}</span>`;

        // Total views
        const viewsCell = row.insertCell();
        viewsCell.innerHTML = `<span style="color: #00ff88; font-weight: 600; font-size: 1.1em;">${exam.viewCount || 0}</span>`;

        // Unique viewers
        const uniqueCell = row.insertCell();
        const uniqueCount = exam.uniqueViewers ? exam.uniqueViewers.length : 0;
        uniqueCell.textContent = uniqueCount;

        // Last viewed
        const lastViewedCell = row.insertCell();
        lastViewedCell.textContent = exam.lastViewed ? formatRelativeTime(exam.lastViewed.toDate()) : 'Never';
      });
    }

  </script>
</body>
</html>
